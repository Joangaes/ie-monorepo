name: Deploy to AWS Elastic Beanstalk (Multi-Container Docker)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-north-1
  EB_APPLICATION_NAME: IeUniversityECS
  EB_ENVIRONMENT_NAME: IeUniversityECS-env
  ECR_REPOSITORY: ie-monorepo

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Abort any in-progress EB update (best-effort)
        run: |
          STATUS=$(aws elasticbeanstalk describe-environments \
            --application-name "$EB_APPLICATION_NAME" \
            --environment-names "$EB_ENVIRONMENT_NAME" \
            --query "Environments[0].Status" --output text || echo "Unknown")
          if [ "$STATUS" = "Updating" ]; then
            echo "Environment is Updating; aborting current operation..."
            aws elasticbeanstalk abort-environment-update \
              --environment-name "$EB_ENVIRONMENT_NAME" || true
            sleep 20
          else
            echo "Environment status: $STATUS"
          fi

      - name: Build & push Django backend image
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY
          docker build -f docker/django.Dockerfile -t $ECR_REPOSITORY_URI:backend .
          docker push $ECR_REPOSITORY_URI:backend
          echo "ECR_REPOSITORY_URI=$ECR_REPOSITORY_URI" >> $GITHUB_ENV

      - name: Build & push Next.js frontend image
        run: |
          # ECR_REPOSITORY_URI already exported in previous step
          docker build -f docker/next.Dockerfile -t $ECR_REPOSITORY_URI:frontend .
          docker push $ECR_REPOSITORY_URI:frontend

      - name: Generate Dockerrun.aws.json with GitHub secrets
        run: |
          envsubst '${ECR_REPOSITORY_URI} ${AWS_REGION} ${DJANGO_ALLOWED_HOSTS} ${DJANGO_SECRET_KEY} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} ${DB_HOST} ${DB_PORT}' \
            < Dockerrun.aws.json > Dockerrun.aws.json.out
          mv Dockerrun.aws.json.out Dockerrun.aws.json
          echo "=== Rendered Dockerrun.aws.json ==="
          cat Dockerrun.aws.json
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          DJANGO_ALLOWED_HOSTS: ${{ secrets.DJANGO_ALLOWED_HOSTS }}
          DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}

      - name: Create deployment package (only what EB needs)
        run: |
          set -euo pipefail
          mkdir -p deploy-package/deploy
          cp deploy/default.conf deploy-package/deploy/default.conf
          cp Dockerrun.aws.json deploy-package/
          cd deploy-package
          zip -r ../deploy.zip .
          cd ..
          unzip -l deploy.zip

      - name: Deploy to EB
        uses: einaregilsson/beanstalk-deploy@v22
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: ${{ env.EB_APPLICATION_NAME }}
          environment_name: ${{ env.EB_ENVIRONMENT_NAME }}
          region: ${{ env.AWS_REGION }}
          version_label: ${{ github.sha }}
          deployment_package: deploy.zip

      - name: Verify deployment (best-effort)
        run: |
          echo "Application URL: http://$EB_ENVIRONMENT_NAME.$AWS_REGION.elasticbeanstalk.com"
          sleep 30
          aws elasticbeanstalk describe-environment-health \
            --environment-name $EB_ENVIRONMENT_NAME \
            --attribute-names Status,Color,Causes \
            --query '{Status:Status,Color:Color,Causes:Causes}' \
            --output table || true