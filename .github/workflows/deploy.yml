name: Deploy to AWS Elastic Beanstalk (Multi-Container Docker)

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  EB_APPLICATION_NAME: ${{ secrets.EB_APPLICATION_NAME }}
  EB_ENVIRONMENT_NAME: ${{ secrets.EB_ENVIRONMENT_NAME }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure envsubst is available
        run: |
          if ! command -v envsubst >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y gettext-base
          fi

      - name: Abort any in-progress EB update (best-effort)
        run: |
          STATUS=$(aws elasticbeanstalk describe-environments \
            --application-name "$EB_APPLICATION_NAME" \
            --environment-names "$EB_ENVIRONMENT_NAME" \
            --query "Environments[0].Status" --output text 2>/dev/null || echo "Unknown")
          if [ "$STATUS" = "Updating" ]; then
            echo "Environment is Updating; aborting current operation..."
            aws elasticbeanstalk abort-environment-update \
              --environment-name "$EB_ENVIRONMENT_NAME" || true
            sleep 20
          else
            echo "Environment status: $STATUS"
          fi

      - name: Build & push Django backend image
        run: |
          set -e
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY
          
          # Build and tag with commit SHA
          docker build -f docker/django.Dockerfile -t $ECR_REPOSITORY_URI:backend-${{ github.sha }} .
          docker build -f docker/django.Dockerfile -t $ECR_REPOSITORY_URI:backend .
          
          # Push both tags
          docker push $ECR_REPOSITORY_URI:backend-${{ github.sha }}
          docker push $ECR_REPOSITORY_URI:backend
          
          echo "ECR_REPOSITORY_URI=$ECR_REPOSITORY_URI" >> $GITHUB_ENV
          echo "BACKEND_IMAGE_TAG=backend-${{ github.sha }}" >> $GITHUB_ENV

      - name: Build & push Next.js frontend image
        run: |
          set -e
          # Build and tag with commit SHA
          docker build -f docker/next.Dockerfile -t $ECR_REPOSITORY_URI:frontend-${{ github.sha }} .
          docker build -f docker/next.Dockerfile -t $ECR_REPOSITORY_URI:frontend .
          
          # Push both tags
          docker push $ECR_REPOSITORY_URI:frontend-${{ github.sha }}
          docker push $ECR_REPOSITORY_URI:frontend
          
          echo "FRONTEND_IMAGE_TAG=frontend-${{ github.sha }}" >> $GITHUB_ENV

      - name: Generate and validate Dockerrun.aws.json with GitHub secrets
        run: |
          set -e

          echo "=== Substituting environment variables in Dockerrun.aws.json ==="
          envsubst '${ECR_REPOSITORY_URI} ${BACKEND_IMAGE_TAG} ${FRONTEND_IMAGE_TAG} ${AWS_REGION} ${DJANGO_ALLOWED_HOSTS} ${DJANGO_SECRET_KEY} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} ${DB_HOST} ${DB_PORT}' \
            < Dockerrun.aws.json > Dockerrun.aws.json.tmp
          mv Dockerrun.aws.json.tmp Dockerrun.aws.json

          echo "=== Validating substitution completed successfully ==="
          if grep -q '\${' Dockerrun.aws.json; then
            echo "❌ ERROR: Found unresolved placeholders in Dockerrun.aws.json:"
            grep '\${' Dockerrun.aws.json || true
            echo "Available environment variables:"
            env | grep -E '^(ECR_REPOSITORY_URI|AWS_REGION|DJANGO_|DB_)' | sort
            exit 1
          else
            echo "✅ All placeholders successfully substituted"
          fi

          echo "=== Validating JSON syntax ==="
          if ! python3 -m json.tool Dockerrun.aws.json > /dev/null; then
            echo "❌ ERROR: Invalid JSON syntax in Dockerrun.aws.json"
            exit 1
          else
            echo "✅ JSON syntax is valid"
          fi

          echo "=== Validating required keys exist ==="
          printf '%s\n' \
            "import json, sys" \
            "" \
            "with open('Dockerrun.aws.json', 'r') as f:" \
            "    data = json.load(f)" \
            "" \
            "required_keys = ['AWSEBDockerrunVersion', 'containerDefinitions', 'volumes']" \
            "missing_keys = [k for k in required_keys if k not in data]" \
            "" \
            "if missing_keys:" \
            "    print(f'❌ ERROR: Missing required keys: {missing_keys}')" \
            "    sys.exit(1)" \
            "" \
            "if data.get('AWSEBDockerrunVersion') != 2:" \
            "    print('❌ ERROR: AWSEBDockerrunVersion must be 2')" \
            "    sys.exit(1)" \
            "" \
            "containers = data.get('containerDefinitions', [])" \
            "if len(containers) != 3:" \
            "    print(f'❌ ERROR: Expected 3 containers, found {len(containers)}')" \
            "    sys.exit(1)" \
            "" \
            "container_names = [c.get('name') for c in containers]" \
            "expected_names = ['django', 'next', 'nginx']" \
            "if sorted(container_names) != sorted(expected_names):" \
            "    print(f'❌ ERROR: Expected containers {expected_names}, found {container_names}')" \
            "    sys.exit(1)" \
            "" \
            "print('✅ All required keys and containers present')" \
          > validate_dockerrun.py
          python3 validate_dockerrun.py

          echo "=== Displaying final Dockerrun.aws.json (with values masked) ==="
          printf '%s\n' \
            "import re" \
            "" \
            "with open('Dockerrun.aws.json', 'r') as f:" \
            "    content = f.read()" \
            "" \
            "# Mask any JSON string value after \"value\": \"...\"" \
            "masked_content = re.sub(r'(\\\"value\\\":\\s*\\\")[^\\\"]*(\\\")', r'\\1***MASKED***\\2', content)" \
            "print(masked_content)" \
          > mask_secrets.py
          python3 mask_secrets.py
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          DJANGO_ALLOWED_HOSTS: ${{ secrets.DJANGO_ALLOWED_HOSTS }}
          DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}

      - name: Create deployment package (only what EB needs)
        run: |
          set -euo pipefail
          mkdir -p deploy-package/deploy
          cp deploy/default.conf deploy-package/deploy/default.conf
          cp Dockerrun.aws.json deploy-package/
          cd deploy-package
          zip -r ../deploy.zip .
          cd ..
          unzip -l deploy.zip

      - name: Deploy to EB
        uses: einaregilsson/beanstalk-deploy@v22
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: ${{ env.EB_APPLICATION_NAME }}
          environment_name: ${{ env.EB_ENVIRONMENT_NAME }}
          region: ${{ env.AWS_REGION }}
          version_label: ${{ github.sha }}
          deployment_package: deploy.zip

      - name: Verify deployment (best-effort)
        run: |
          echo "Application URL: http://$EB_ENVIRONMENT_NAME.$AWS_REGION.elasticbeanstalk.com"
          sleep 30
          aws elasticbeanstalk describe-environment-health \
            --environment-name $EB_ENVIRONMENT_NAME \
            --attribute-names Status,Color,Causes \
            --query '{Status:Status,Color:Color,Causes:Causes}' \
            --output table || true
