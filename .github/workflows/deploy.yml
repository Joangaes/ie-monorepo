name: Deploy to AWS Elastic Beanstalk (Multi-Container Docker)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-north-1
  EB_APPLICATION_NAME: IeUniversityECS
  EB_ENVIRONMENT_NAME: IeUniversityECS-env
  ECR_REPOSITORY: ie-monorepo

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Abort any in-progress EB update (best-effort)
        run: |
          STATUS=$(aws elasticbeanstalk describe-environments \
            --application-name "$EB_APPLICATION_NAME" \
            --environment-names "$EB_ENVIRONMENT_NAME" \
            --query "Environments[0].Status" --output text || echo "Unknown")
          if [ "$STATUS" = "Updating" ]; then
            echo "Environment is Updating; aborting current operation..."
            aws elasticbeanstalk abort-environment-update \
              --environment-name "$EB_ENVIRONMENT_NAME" || true
            sleep 20
          else
            echo "Environment status: $STATUS"
          fi

      - name: Build & push Django backend image
        run: |
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY
          docker build -f docker/django.Dockerfile -t $ECR_REPOSITORY_URI:backend .
          docker push $ECR_REPOSITORY_URI:backend
          echo "ECR_REPOSITORY_URI=$ECR_REPOSITORY_URI" >> $GITHUB_ENV

      - name: Build & push Next.js frontend image
        run: |
          # ECR_REPOSITORY_URI already exported in previous step
          docker build -f docker/next.Dockerfile -t $ECR_REPOSITORY_URI:frontend .
          docker push $ECR_REPOSITORY_URI:frontend

      - name: Generate and validate Dockerrun.aws.json with GitHub secrets
        run: |
          echo "=== Substituting environment variables in Dockerrun.aws.json ==="
          
          # Perform environment variable substitution
          envsubst '${ECR_REPOSITORY_URI} ${AWS_REGION} ${DJANGO_ALLOWED_HOSTS} ${DJANGO_SECRET_KEY} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} ${DB_HOST} ${DB_PORT}' \
            < Dockerrun.aws.json > Dockerrun.aws.json.tmp
          mv Dockerrun.aws.json.tmp Dockerrun.aws.json
          
          echo "=== Validating substitution completed successfully ==="
          # Check if any placeholders remain unresolved (this will fail the pipeline if found)
          if grep -q '\${' Dockerrun.aws.json; then
            echo "❌ ERROR: Found unresolved placeholders in Dockerrun.aws.json:"
            grep '\${' Dockerrun.aws.json || true
            echo "Available environment variables:"
            env | grep -E '^(ECR_REPOSITORY_URI|AWS_REGION|DJANGO_|DB_)' | sort
            exit 1
          else
            echo "✅ All placeholders successfully substituted"
          fi
          
          echo "=== Validating JSON syntax ==="
          # Validate JSON syntax
          if ! python3 -m json.tool Dockerrun.aws.json > /dev/null; then
            echo "❌ ERROR: Invalid JSON syntax in Dockerrun.aws.json"
            exit 1
          else
            echo "✅ JSON syntax is valid"
          fi
          
          echo "=== Validating required keys exist ==="
          # Check required keys exist
          cat > validate_dockerrun.py << 'EOF'
import json
import sys

with open('Dockerrun.aws.json', 'r') as f:
    data = json.load(f)

required_keys = ['AWSEBDockerrunVersion', 'containerDefinitions', 'volumes']
missing_keys = [key for key in required_keys if key not in data]

if missing_keys:
    print('❌ ERROR: Missing required keys: {}'.format(missing_keys))
    sys.exit(1)

if data.get('AWSEBDockerrunVersion') != 2:
    print('❌ ERROR: AWSEBDockerrunVersion must be 2')
    sys.exit(1)

containers = data.get('containerDefinitions', [])
if len(containers) != 3:
    print('❌ ERROR: Expected 3 containers, found {}'.format(len(containers)))
    sys.exit(1)

container_names = [c.get('name') for c in containers]
expected_names = ['django', 'next', 'nginx']
if sorted(container_names) != sorted(expected_names):
    print('❌ ERROR: Expected containers {}, found {}'.format(expected_names, container_names))
    sys.exit(1)

print('✅ All required keys and containers present')
EOF
          python3 validate_dockerrun.py
          
          echo "=== Displaying final Dockerrun.aws.json (with secrets masked) ==="
          # Show the final file with secrets masked for security
          cat > mask_secrets.py << 'EOF'
import json
import re

with open('Dockerrun.aws.json', 'r') as f:
    content = f.read()

# Mask sensitive values in environment variables
masked_content = re.sub(
    r'(\"value\":\s*\")([^\"]*)(\".*(?:SECRET_KEY|PASSWORD|DB_USER))',
    r'\1***MASKED***\3',
    content
)

print(masked_content)
EOF
          python3 mask_secrets.py
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          DJANGO_ALLOWED_HOSTS: ${{ secrets.DJANGO_ALLOWED_HOSTS }}
          DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}

      - name: Create deployment package (only what EB needs)
        run: |
          set -euo pipefail
          mkdir -p deploy-package/deploy
          cp deploy/default.conf deploy-package/deploy/default.conf
          cp Dockerrun.aws.json deploy-package/
          cd deploy-package
          zip -r ../deploy.zip .
          cd ..
          unzip -l deploy.zip

      - name: Deploy to EB
        uses: einaregilsson/beanstalk-deploy@v22
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: ${{ env.EB_APPLICATION_NAME }}
          environment_name: ${{ env.EB_ENVIRONMENT_NAME }}
          region: ${{ env.AWS_REGION }}
          version_label: ${{ github.sha }}
          deployment_package: deploy.zip

      - name: Verify deployment (best-effort)
        run: |
          echo "Application URL: http://$EB_ENVIRONMENT_NAME.$AWS_REGION.elasticbeanstalk.com"
          sleep 30
          aws elasticbeanstalk describe-environment-health \
            --environment-name $EB_ENVIRONMENT_NAME \
            --attribute-names Status,Color,Causes \
            --query '{Status:Status,Color:Color,Causes:Causes}' \
            --output table || true