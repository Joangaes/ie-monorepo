name: Deploy to AWS Elastic Beanstalk (Multi-Container Docker)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-north-1
  EB_APPLICATION_NAME: Ieuniversitydocker
  EB_ENVIRONMENT_NAME: Ieuniversitydocker-env
  ECR_REPOSITORY: ie-monorepo

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Login to Amazon ECR
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # Optional: if EB is "Updating", abort it so a new deploy can proceed
      - name: Abort any in-progress EB update (best-effort)
        run: |
          STATUS=$(aws elasticbeanstalk describe-environments \
            --application-name "$EB_APPLICATION_NAME" \
            --environment-names "$EB_ENVIRONMENT_NAME" \
            --query "Environments[0].Status" --output text || echo "Unknown")
          if [ "$STATUS" = "Updating" ]; then
            echo "Environment is Updating; aborting current operation..."
            aws elasticbeanstalk abort-environment-update \
              --environment-name "$EB_ENVIRONMENT_NAME" || true
            # Small wait so EB flips out of Updating state
            sleep 20
          else
            echo "Environment status: $STATUS"
          fi

      # Build and push backend (Django) image
      - name: Build and push Django backend image
        run: |
          # Get AWS account ID
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY
          
          # Build Django image
          docker build -f docker/django.Dockerfile -t $ECR_REPOSITORY_URI:backend .
          
          # Push Django image
          docker push $ECR_REPOSITORY_URI:backend
          
          echo "Backend image pushed: $ECR_REPOSITORY_URI:backend"

      # Build and push frontend (Next.js) image
      - name: Build and push Next.js frontend image
        run: |
          # Get AWS account ID
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY
          
          # Build Next.js image
          docker build -f docker/next.Dockerfile -t $ECR_REPOSITORY_URI:frontend .
          
          # Push Next.js image
          docker push $ECR_REPOSITORY_URI:frontend
          
          echo "Frontend image pushed: $ECR_REPOSITORY_URI:frontend"

      # Generate Dockerrun.aws.json with environment variables
      - name: Generate Dockerrun.aws.json with secrets
        run: |
          # Get AWS account ID
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REPOSITORY_URI=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY
          
          # Substitute environment variables in Dockerrun.aws.json
          envsubst '${ECR_REPOSITORY_URI} ${AWS_REGION} ${DJANGO_ALLOWED_HOSTS} ${DJANGO_SECRET_KEY} ${DB_NAME} ${DB_USER} ${DB_PASSWORD} ${DB_HOST} ${DB_PORT}' < Dockerrun.aws.json > Dockerrun.aws.json.tmp
          mv Dockerrun.aws.json.tmp Dockerrun.aws.json
          
          # Verify the generated file
          echo "Generated Dockerrun.aws.json:"
          cat Dockerrun.aws.json
        env:
          DJANGO_ALLOWED_HOSTS: ${{ secrets.DJANGO_ALLOWED_HOSTS }}
          DJANGO_SECRET_KEY: ${{ secrets.DJANGO_SECRET_KEY }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}

      # Create deployment package
      - name: Create deployment package
        run: |
          set -euo pipefail
          
          # Create deployment directory
          mkdir -p deploy-package/deploy
          
          # Copy nginx configuration to deploy directory
          cp deploy/nginx.conf deploy-package/deploy/default.conf
          
          # Copy the generated Dockerrun.aws.json
          cp Dockerrun.aws.json deploy-package/
          
          # Create deployment zip containing only required files
          cd deploy-package
          zip -r ../deploy.zip .
          cd ..
          
          # Verify deployment package contents
          echo "Deployment package contents:"
          unzip -l deploy.zip

      # Deploy to Elastic Beanstalk
      - name: Deploy to EB
        uses: einaregilsson/beanstalk-deploy@v22
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: ${{ env.EB_APPLICATION_NAME }}
          environment_name: ${{ env.EB_ENVIRONMENT_NAME }}
          region: ${{ env.AWS_REGION }}
          version_label: ${{ github.sha }}
          deployment_package: deploy.zip

      # Verify deployment
      - name: Verify deployment
        run: |
          echo "Deployment completed successfully!"
          echo "Application URL: http://$EB_ENVIRONMENT_NAME.$AWS_REGION.elasticbeanstalk.com"
          
          # Wait a bit for the deployment to stabilize
          sleep 30
          
          # Check environment health
          aws elasticbeanstalk describe-environment-health \
            --environment-name $EB_ENVIRONMENT_NAME \
            --attribute-names Status,Color,Causes \
            --query '{Status:Status,Color:Color,Causes:Causes}' \
            --output table || echo "Health check failed, but deployment may still be in progress"